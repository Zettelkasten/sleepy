# OpenGL bindings via GLFW for sleepy.
# Compile using
# sleepy opengl.slp --compile-libs GL GLU glfw3 X11 Xxf86vm Xrandr pthread Xi dl m


### Vector / Matrix functions ###
@RefType struct Vector {
  Int size = 0;
  FloatPtr start = allocate_float(0);
}
func get(Vector vec, Int pos) -> Float {
  assert(and(0 <= pos, pos < vec.size));
  return load(vec.start + pos);
}
func set(@Mutable Vector vec, Int pos, Float val) {
  assert(and(0 <= pos, pos < vec.size));
  store(vec.start + pos, val);
}
func fill(@Mutable Vector vec, Float val) {
  pos = 0;
  while pos < vec.size {
    vec[pos] = val;
    pos += 1;
  }
}
func ZeroVector(Int size) -> @Mutable Vector {
  @Mutable v = Vector(size, allocate_float(size));
  fill(v, 0.0f);
  return v;
}
func print(Vector vec) {
  print('[');
  pos = 0;
  while pos < vec.size {
    print(vec[pos]);
    pos += 1;
    if pos < vec.size { print(','); print(' '); }
  }
  print(']');
}
func print_line(Vector vec) { print(vec); print_line(); }
@RefType struct Matrix {
  Int dim_x = 0; Int dim_y = 0;
  FloatPtr start = allocate_float(0);
}
func get(Matrix mat, Int x, Int y) -> Float {
  assert(and(0 <= x, x < mat.dim_x));
  assert(and(0 <= y, y < mat.dim_y));
  return load(mat.start + x * mat.dim_x + y);
}
func set(@Mutable Matrix mat, Int x, Int y, Float val) {
  assert(and(0 <= x, x < mat.dim_x));
  assert(and(0 <= y, y < mat.dim_y));
  store(mat.start + x * mat.dim_x + y, val);
}
func fill(@Mutable Matrix mat, Float val) {
  x = 0;
  while x < mat.dim_x {
    y = 0;
    while y < mat.dim_y {
      mat[x, y] = val;
      y += 1;
    }
    x += 1;
  }
}
func ZeroMatrix(Int xs, Int ys) -> @Mutable Matrix {
  @Mutable m = Matrix(xs, ys, allocate_float(xs * ys));
  fill(m, 0.0f);
  return m;
}
func IdentityMatrix(Int dim) -> @Mutable Matrix {
  @Mutable mat = ZeroMatrix(dim, dim);
  pos = 0;
  while pos < dim {
    mat[pos, pos] = 1.0f;
    pos += 1;
  }
  return mat;
}
func print(Matrix mat) {
  print('[');
  x = 0;
  while x < mat.dim_x {
    y = 0;
    print('[');
    while y < mat.dim_y {
      print(mat[x, y]);
      y += 1;
      if y < mat.dim_y { print(' '); }
    }
    print(']');
    x += 1;
    if x < mat.dim_x { print(' '); }
  }
  print(']');
}
func print_line(Matrix mat) { print(mat); print_line(); }


### Reading Files ###
func read_file(Str file_name) -> @Mutable Str {
  struct File { IntPtr ptr = NullIntPtr(); }
  struct SeekOrigin { Int val = 0; }
  func SeekBeginning() -> SeekOrigin { return SeekOrigin(0); }
  func SeekCurrent() -> SeekOrigin { return SeekOrigin(1); }
  func SeekEnd() -> SeekOrigin { return SeekOrigin(2); }
  extern_func fopen(CharPtr file_name, CharPtr mode) -> File;
  extern_func fseek(File stream, Long offset, SeekOrigin origin) -> Int;
  extern_func ftell(File stream) -> Long;
  extern_func rewind(File stream);
  extern_func fread(CharPtr buffer, Long size, Long count, File stream) -> Long;
  extern_func fclose(File stream) -> Int;

  file_name += '\0';
  mode = "rb\0";

  file = fopen(file_name.start, mode.start);
  if file.ptr == NullIntPtr() {
    assert(False(), "Cannot open: " + file_name);
  }
  fseek(file, 0l, SeekEnd());    # go to end of file
  Long file_size = ftell(file);  # get position (= file size)
  rewind(file);                  # go back to front
  if ToLong(ToInt(file_size)) != file_size {
    assert(False(), "File too big: " + file_name);
  }

  @Mutable file_content = EmptyStr(ToInt(file_size));
  fread(file_content.start, file_size, 1l, file);  # read file content
  file_content.length = ToInt(file_size);

  if fclose(file) != 0 {
    assert(False(), "Cannot close: " + file_name);
  }
  free(file_name);  free(mode);
  return file_content;
}


### GLFW Functions ###
extern_func glfwInit() -> Int;
extern_func glfwTerminate() -> Int;

struct GLFWMonitor { CharPtr ptr = NullCharPtr(); }
@Inline func NullGLFWMonitor() -> GLFWMonitor { return GLFWMonitor(NullCharPtr()); }

struct GLFWWindow { CharPtr ptr = NullCharPtr(); }
@Inline func NullGLFWWindow() -> GLFWWindow { return GLFWWindow(NullCharPtr()); }
@Inline func ==(GLFWWindow a, GLFWWindow b) -> Bool { return a.ptr == b.ptr; }

extern_func glfwCreateWindow(Int width, Int height, CharPtr title, GLFWMonitor monitor, GLFWWindow share) -> GLFWWindow;
extern_func glfwGetPrimaryMonitor() -> GLFWMonitor;
func destroy(GLFWWindow window) {
  extern_func glfwDestroyWindow(GLFWWindow window);
  glfwDestroyWindow(window);
}
func make_current_context(GLFWWindow window) {
  extern_func glfwMakeContextCurrent(GLFWWindow window);
  glfwMakeContextCurrent(window);
}
func should_close(GLFWWindow window) -> Bool {
  extern_func glfwWindowShouldClose(GLFWWindow window) -> Int;
  return glfwWindowShouldClose(window) == 1;
}
func swap_buffers(GLFWWindow window) {
  extern_func glfwSwapBuffers(GLFWWindow window);
  glfwSwapBuffers(window);
}

struct GLFWInputMode { Int val = 0x0; }
func GLFWStickyKeys() -> GLFWInputMode { return GLFWInputMode(0x00033002); }
func set_sticky_keys(GLFWWindow window, Bool enable) {
  extern_func glfwSetInputMode(GLFWWindow window, GLFWInputMode mode, Int value);
  glfwSetInputMode(window, GLFWStickyKeys(), ToInt(enable));
}
extern_func glfwPollEvents();
struct Key { Int code = 0; }
func EscapeKey() -> Key { return Key(256); }
struct GLFWKeyState { Int val = 0; }
func KeyRelease() -> GLFWKeyState { return GLFWKeyState(0); }
func KeyPress() -> GLFWKeyState { return GLFWKeyState(1); }
func KeyRepeat() -> GLFWKeyState { return GLFWKeyState(2); }
func ==(GLFWKeyState a, GLFWKeyState b) -> Bool { return a.val == b.val; }
extern_func glfwGetKey(GLFWWindow window, Key key) -> GLFWKeyState;

struct WindowHintTarget { Int val = 0; }
func SamplesWindowHint() -> WindowHintTarget { return WindowHintTarget(0x0002100D); }
extern_func glfwWindowHint(WindowHintTarget target, Int hint);
func set_samples(Int num_samples) {
  glfwWindowHint(SamplesWindowHint(), num_samples);
}

### GL Functions ###
extern_func glClearColor(Float red, Float green, Float blue, Float alpha);
struct ClearMask { Int bits = 0x0; }
func ColorBufferBit() -> ClearMask { return ClearMask(0x00004000); }
func DepthBufferBit() -> ClearMask { return ClearMask(0x00000100); }
func or(ClearMask a, ClearMask b) -> ClearMask {
  return ClearMask(bitwise_or(a.bits, b.bits));
}

func clear(ClearMask clear_mask) {
  extern_func glClear(Int clear_mask);
  glClear(clear_mask.bits);
}

struct VertexArray { Int id = 0; }
func generate_vertex_array() -> VertexArray {
  extern_func glGenVertexArrays(Int n, IntPtr arrays);
  # as there is no reference operator yet, temporarily allocate some memory to obtain the id.
  tmp_ptr = allocate_int(1);
  glGenVertexArrays(1, tmp_ptr);
  arr = VertexArray(load(tmp_ptr));
  deallocate(tmp_ptr);
  return arr;
}
func bind(VertexArray arr) {
  extern_func glBindVertexArray(VertexArray array);
  glBindVertexArray(arr);
}

struct Buffer { Int id = 0; }
func generate_buffer() -> Buffer {
  extern_func glGenBuffers(Int n, IntPtr buffers);
  # as there is no reference operator yet, temporarily allocate some memory to obtain the id.
  tmp_ptr = allocate_int(1);
  glGenBuffers(1, tmp_ptr);
  buffer = Buffer(load(tmp_ptr));
  deallocate(tmp_ptr);
  return buffer;
}
struct BufferTarget { Int val = 0; }
func ArrayBufferTarget() -> BufferTarget { return BufferTarget(0x8892); }
func bind(BufferTarget target, Buffer buffer) {
  extern_func glBindBuffer(BufferTarget target, Buffer buffer);
  glBindBuffer(target, buffer);
}
struct BufferUsage { Int val = 0; }
func StaticDrawBufferUsage() -> BufferUsage { return BufferUsage(0x88E4); }
func set_data(BufferTarget target, Vector data, BufferUsage usage) {
  extern_func glBufferData(BufferTarget target, Int size, FloatPtr data, BufferUsage usage);
  glBufferData(target, 4 * data.size, data.start, usage);  # 4 bytes per Float.
}

extern_func glEnableVertexAttribArray(Int attrib_idx);
extern_func glDisableVertexAttribArray(Int attrib_idx);
struct AttribType { Int val = 0; }
func FloatAttribType() -> AttribType { return AttribType(0x1406); }
extern_func glVertexAttribPointer(Int attrib_idx, Int size, AttribType attrib_type, Bool normalized, Int stride, IntPtr ptr);
struct DrawMode { Int val = 0; }
func TrianglesDrawMode() -> DrawMode { return DrawMode(0x0004); }
extern_func glDrawArrays(DrawMode mode, Int first, Int count);
struct Capability { Int val = 0; }
func Multisample() -> Capability { return Capability(0x809D); }
extern_func glEnable(Capability cap);

struct ShaderType { Int val = 0; }
func FragmentShaderType() -> ShaderType { return ShaderType(0x8B30); }
func VertexShaderType() -> ShaderType { return ShaderType(0x8B31); }
struct Shader { Int id = 0; }
func create_shader(ShaderType shader_type) -> Shader {
  extern_func glCreateShader(ShaderType shader_type) -> Shader;
  return glCreateShader(shader_type);
}
func set_source(Shader shader, Str shader_code) {
  # string argument is actually of type CharCharPtr, which do not exist yet (use LongPtr + unsafe cast for now).
  extern_func glShaderSource(Shader shader, Int count, LongPtr string, IntPtr length);
  # as there is no reference operator yet, temporarily allocate some memory to obtain the string and length.
  code_ptr = allocate_long(1);
  store(code_ptr, ToLong(shader_code.start));
  len_ptr = allocate_int(1);
  store(len_ptr, shader_code.length);
  glShaderSource(shader, 1, code_ptr, len_ptr);
  deallocate(code_ptr);
  deallocate(len_ptr);
}
func compile(Shader shader) {
  extern_func glCompileShader(Shader shader);
  glCompileShader(shader);
}
struct ShaderParameter { Int val = 0; }
func ShaderCompileStatus() -> ShaderParameter { return ShaderParameter(0x8B81); }
func ShaderInfoLogLength() -> ShaderParameter { return ShaderParameter(0x8B84); }
extern_func glGetShaderiv(Shader shader, ShaderParameter pname, IntPtr params);
struct CompileSuccess { }
struct CompileError { Str message = ""; }
func print(CompileSuccess status) { print("Compile Success"); }
func print(CompileError status) { print("Compile Error:\n"); print(status.message); }
func print_line(CompileSuccess|CompileError status) { print(status); print_line(); }
func get_compile_status(Shader shader) -> CompileSuccess|CompileError {
  res = allocate_int(1);
  glGetShaderiv(shader, ShaderCompileStatus(), res);
  success = ToBool(load(res));
  if success {
    deallocate(res);
    return CompileSuccess();
  } else {
    # get error message
    glGetShaderiv(shader, ShaderInfoLogLength(), res);
    log_length = load(res);
    @Mutable log = EmptyStr(log_length);
    extern_func glGetShaderInfoLog(Shader shader, Int max_length, IntPtr length, CharPtr info_log);
    glGetShaderInfoLog(shader, log.alloc_length, res, log.start);
    log.length = load(res);
    deallocate(res);
    return CompileError(log);
  }
}
func delete_shader(Shader shader) {
  extern_func glDeleteShader(Shader shader);
  glDeleteShader(shader);
}
struct ShaderProgram { Int id = 0; }
func create_shader_program() -> ShaderProgram {
  extern_func glCreateProgram() -> ShaderProgram;
  return glCreateProgram();
}
func attach_shader(ShaderProgram program, Shader shader) {
  extern_func glAttachShader(ShaderProgram program, Shader shader);
  glAttachShader(program, shader);
}
func link(ShaderProgram program) {
  extern_func glLinkProgram(ShaderProgram program);
  glLinkProgram(program);
}
struct ShaderProgramParameter { Int val = 0; }
func ShaderProgramLinkStatus() -> ShaderProgramParameter { return ShaderProgramParameter(0x8B82); }
func ShaderProgramInfoLogLength() -> ShaderProgramParameter { return ShaderProgramParameter(0x8B84); }
extern_func glGetProgramiv(ShaderProgram shader, ShaderProgramParameter pname, IntPtr params);
struct LinkSuccess { }
struct LinkError { Str message = ""; }
func print(LinkSuccess status) { print("Link Success"); }
func print(LinkError status) { print("Link Error:\n"); print(status.message); }
func print_line(LinkSuccess|LinkError status) { print(status); print_line(); }
func get_link_status(ShaderProgram program) -> LinkSuccess|LinkError {
  res = allocate_int(1);
  glGetProgramiv(program, ShaderProgramLinkStatus(), res);
  success = ToBool(load(res));
  if success {
    deallocate(res);
    return LinkSuccess();
  } else {
    # get error message
    glGetProgramiv(program, ShaderProgramInfoLogLength(), res);
    log_length = load(res);
    @Mutable log = EmptyStr(log_length);
    extern_func glGetProgramInfoLog(ShaderProgram program, Int max_length, IntPtr length, CharPtr info_log);
    glGetProgramInfoLog(program, log.alloc_length, res, log.start);
    log.length = load(res);
    deallocate(res);
    return LinkError(log);
  }
}
func detach_shader(ShaderProgram program, Shader shader) {
  extern_func glDetachShader(ShaderProgram program, Shader shader);
  glDetachShader(program, shader);
}
func use(ShaderProgram program) {
  extern_func glUseProgram(ShaderProgram program);
  glUseProgram(program);
}
struct UniformLocation { Int id = 0; }
func get_uniform_location(ShaderProgram program, Str uniform_name) -> UniformLocation {
  extern_func glGetUniformLocation(ShaderProgram program, CharPtr name) -> UniformLocation;
  uniform_name += '\0';
  uniform = glGetUniformLocation(program, uniform_name.start);
  assert(uniform.id != -1, "Cannot get uniform " + uniform_name);  # error code.
  free(uniform_name);
  return uniform;
}
func set_uniform(UniformLocation location, Vector data) {
  # Sleepy does not support else if yet.
  if data.size == 1 {
    extern_func glUniform1f(UniformLocation location, Float v0);
    glUniform1f(location, data[0]);
    return;
  } if data.size == 2 {
    extern_func glUniform2f(UniformLocation location, Float v0, Float v1);
    glUniform2f(location, data[0], data[1]);
    return;
  } if data.size == 3 {
    extern_func glUniform3f(UniformLocation location, Float v0, Float v1, Float v2);
    glUniform3f(location, data[0], data[1], data[2]);
    return;
   }
   assert(False(), "Not supported yet");
}
func set_uniform(UniformLocation location, Matrix data) {
  if and(data.dim_x == 2, data.dim_y == 2) {
    extern_func glUniformMatrix2fv(UniformLocation location, Int count, Bool transpose, FloatPtr value);
    glUniformMatrix2fv(location, 1, False(), data.start);
    return;
  } if and(data.dim_x == 3, data.dim_y == 3) {
    extern_func glUniformMatrix3fv(UniformLocation location, Int count, Bool transpose, FloatPtr value);
    glUniformMatrix3fv(location, 1, False(), data.start);
    return;
  } if and(data.dim_x == 4, data.dim_y == 4) {
    extern_func glUniformMatrix4fv(UniformLocation location, Int count, Bool transpose, FloatPtr value);
    glUniformMatrix4fv(location, 1, False(), data.start);
    return;
  }
  assert(False(), "Not supported yet");
}

func terminate(Str error) {
  print("Error happened: ");
  print_line(error);
  glfwTerminate();
  assert(False());
}

func make_vertices_data() -> Vector {
  @Mutable data = ZeroVector(9);
  data[0] = -0.8f; data[1] = -0.8f;
  data[3] = 0.8f;  data[4] = -0.8f;
                   data[7] = 0.8f;
  print_line(data);
  return data;
}

func reload(ShaderProgram program, Str vertex_shader_path, Str fragment_shader_path) {
  vertex_shader_code = read_file(vertex_shader_path);
  fragment_shader_code = read_file(fragment_shader_path);
  vertex_shader = create_shader(VertexShaderType());
  fragment_shader = create_shader(FragmentShaderType());
  set_source(vertex_shader, vertex_shader_code);
  set_source(fragment_shader, fragment_shader_code);
  compile(vertex_shader);
  compile(fragment_shader);
  print_line(get_compile_status(vertex_shader));
  print_line(get_compile_status(fragment_shader));

  attach_shader(program, vertex_shader);
  attach_shader(program, fragment_shader);
  link(program);
  print_line(get_link_status(program));
  detach_shader(program, vertex_shader);
  detach_shader(program, fragment_shader);
  delete_shader(vertex_shader);
  delete_shader(fragment_shader);
}
func make_program(Str vertex_shader_path, Str fragment_shader_path) -> ShaderProgram {
  program = create_shader_program();
  reload(program, vertex_shader_path, fragment_shader_path);
  return program;
}

func main() {
  if glfwInit() != 1 {
    print_line("Init error");
    assert(False());
  }

  set_samples(4);

  fullscreen = False();
  monitor = NullGLFWMonitor();
  if fullscreen { monitor = glfwGetPrimaryMonitor(); }
  GLFWWindow window = glfwCreateWindow(640, 480, "Hello, World!\0".start, monitor, NullGLFWWindow());
  if window == NullGLFWWindow() { terminate("Could not make window"); }

  make_current_context(window);
  set_sticky_keys(window, True());
  glClearColor(0.2f, 0.8f, 0.2f, 0.0f);
  glEnable(Multisample());

  vertex_array = generate_vertex_array();
  bind(vertex_array);
  vertex_buffer = generate_buffer();
  bind(ArrayBufferTarget(), vertex_buffer);
  set_data(ArrayBufferTarget(), make_vertices_data(), StaticDrawBufferUsage());

  vertex_shader_path = "shaders/vertex.glsl";
  fragment_shader_path = "shaders/fragment.glsl";
  program = make_program(vertex_shader_path, fragment_shader_path);
  projection_uniform = get_uniform_location(program, "projection");
  @Mutable projection = IdentityMatrix(4);

  while not(or(should_close(window), glfwGetKey(window, EscapeKey()) == KeyPress())) {
    clear(or(ColorBufferBit(), DepthBufferBit()));

    use(program);
    glEnableVertexAttribArray(0);
    bind(ArrayBufferTarget(), vertex_buffer);
    glVertexAttribPointer(0, 3, FloatAttribType(), False(), 0, NullIntPtr());
    set_uniform(projection_uniform, projection);
    glDrawArrays(TrianglesDrawMode(), 0, 3);
    glDisableVertexAttribArray(0);

    swap_buffers(window);
    glfwPollEvents();
  }

  destroy(window);
  print_line("Goodbye.");
  glfwTerminate();
}
