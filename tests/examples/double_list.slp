@RefType struct DoubleList {
  pointer : Ptr[Double] = allocate_double(8);
  alloc_length : Int = 8;
  length : Int = 0;
}
func empty_list() -> @Mutable  DoubleList  {
  return DoubleList(allocate_double(8), 8, 0);
}
func get(l: DoubleList, idx: Int) ->  Double  {
  assert(and(idx >= 0, idx < l.length));
  return load(l.pointer + idx);
}
func set(@Mutable l: DoubleList, idx: Int, val: Double)  {
  # compiler cannot enforce that the list has to be mutable, but we will anyway.
  assert(and(idx >= 0, idx < l.length));
  store(l.pointer + idx, val);
}
func insert(@Mutable l: DoubleList, val: Double)  {
  if l.length >= l.alloc_length {
    # no space left, resize
    new_alloc_length = 2 * l.alloc_length;
    new_pointer = allocate_double(new_alloc_length);
    memcpy(new_pointer, l.pointer, l.alloc_length * 8);
    deallocate(l.pointer);
    l.alloc_length = new_alloc_length;
    l.pointer = new_pointer;
  }
  new_idx = l.length;
  l.length = l.length + 1;
  set(l, new_idx, val);
}
func insert_all(@Mutable l: DoubleList, other: DoubleList)  {
  # could be smarter: e.g. use memcpy
  other_length = other.length;  # store in case l == other, we do not want to increase this.
  # To make this nicer: use a range(..) object and iterate over that
  idx = 0;
  while idx < other_length {
    insert(l, get(other, idx));
    idx = idx + 1;
  }
  # Thoughts: This function is problematic, if l == other.
  # Then, we would ideally want other to be a copy of l before we do anything
}
func remove(@Mutable l: DoubleList, idx: Int)  {
  assert(and(idx >= 0, idx < l.length));
  # move all elements after idx one to front
  move_idx = idx + 1;
  while move_idx < l.length {
    set(l, move_idx - 1, get(l, move_idx));
    move_idx = move_idx + 1;
  }
  l.length = l.length - 1;
}

func print(l: DoubleList)  {
  print('[');
  idx = 0;
  while idx < l.length {
    print(get(l, idx));
    idx = idx + 1;
    if idx < l.length { print(','); }
  }
  print(']');
}
func print_line(l: DoubleList)  { print(l); print('\n'); }
func print_len(l: DoubleList)  { print('l'); print('e'); print('n'); print(':'); print(' '); print_line(l.length); }

func main()  {
  @Mutable l = empty_list();
  print_line(l);
  insert(l, 4.2);
  insert(l, 12.0);
  insert(l, 7.0);
  print_line(l);
  # add a whole bunch of elements to test that resizing works.
  s = 1.0;
  while s > 0.0 {
    s = s - 0.01;
    insert(l, s);
  }
  insert(l, 123.0);
  remove(l, 1);
  print_len(l);
  print_line(l);
  insert_all(l, l);
  print_len(l);
  print_line(l);
  free(l);
}
